package formatting

import (
    . "TypeGo/core"
    "strings"
)

fn IntLoopAction LoopUntilEndInner(*FormatData formatData, *BlockData blockData, Token token, IntTokenType lastTokenType, *BracketCounts bracket_counts, bool stopAtSemicolon) {
    
    formatData.SetErrorFunction("LoopUntilEndInner");

    if token.Type == TokenType.LeftSquareBracket {
        bracket_counts.OpenSqCount += 1;
        return LoopAction.Continue;
    }
    if token.Type == TokenType.RightSquareBracket {
        bracket_counts.OpenSqCount -= 1;
        return LoopAction.Continue;
    }

    if token.Type == TokenType.LeftParenthesis {
        bracket_counts.OpenBracketCount += 1;
        return LoopAction.Continue;
    }
    if token.Type == TokenType.RightParenthesis {
        bracket_counts.OpenBracketCount -= 1;
        return LoopAction.Continue;
    }

    if token.Type == TokenType.LeftBrace {
        bracket_counts.OpenBraceCount += 1;
        return LoopAction.Continue;
    }
    if token.Type == TokenType.RightBrace {
        bracket_counts.OpenBraceCount -= 1;
        return LoopAction.Continue;
    }

    if bracket_counts.AreAllZero() == false {
        return LoopAction.Continue;
    }

    if stopAtSemicolon == true {

        if token.Type == TokenType.Semicolon {

            blockData.Tokens.append(token);
            return LoopAction.Break;
        }
    }
    if token.Type == TokenType.NewLine {

        blockData.Tokens.append(token);
        if IsLineContinuingToken(lastTokenType) == false {
            formatData.Increment();
            return LoopAction.Break;
        }
    }
    if token.Type == TokenType.EndComment {
        return LoopAction.Break;
    }
    return LoopAction.Continue;
}

fn LoopTokensUntilLineEnd(*FormatData formatData, *BlockData blockData, bool stopAtSemicolon) {

    formatData.SetErrorFunction("LoopTokensUntilLineEnd");

    IntTokenType lastTokenType = TokenType.NA;

    BracketCounts bracket_counts
    bracket_counts.OpenBraceCount = 0
    bracket_counts.OpenBracketCount = 0
    bracket_counts.OpenSqCount = 0

    for formatData.IndexInBounds() {

        Token tempToken = formatData.GetToken();
        if formatData.IsValidToken(tempToken) == false {
            break;
        }
        Token token = tempToken;
        IntLoopAction loopResult = LoopUntilEndInner(formatData, blockData, token, lastTokenType, &bracket_counts, stopAtSemicolon);
        if loopResult == LoopAction.Break {
            lastTokenType = token.Type;
            break;
        }

        formatData.Increment();
        blockData.Tokens.append(token);
        lastTokenType = token.Type;
    }

    if lastTokenType == TokenType.Semicolon {

        formatData.Increment();
        Token tempToken = formatData.GetToken();
        if formatData.IsValidToken(tempToken) {

            if tempToken.Type == TokenType.NewLine {
                formatData.Increment();
            }
        }
    }
}

fn bool IsLineContinuingToken(IntTokenType token_type) {
    switch token_type {

	case TokenType.Minus, TokenType.Plus, TokenType.Divide, TokenType.Multiply, TokenType.Equals, TokenType.And,
		TokenType.AndAnd, TokenType.Or, TokenType.OrOr, TokenType.PlusEquals, TokenType.MinusEquals, TokenType.MultiplyEquals,
		TokenType.DivideEquals, TokenType.GreaterThan, TokenType.LessThan, TokenType.EqualsEquals, TokenType.GreaterThanEquals,
		TokenType.LessThanEquals, TokenType.Modulus, TokenType.ModulusEquals, TokenType.NotEquals, TokenType.LeftBrace,
		TokenType.LeftSquareBracket, TokenType.Comma, TokenType.FullStop:
            return true;
        
        default:
            return false;
    }
    return false
}

fn bool IsInfiniteWhile(*int count, int max) {
    *count += 1
    return *count >= max
}

fn bool IsPointerDeclaration(*FormatData formatData) {

    formatData.SetErrorFunction("IsPointerDeclaration");

    int index = formatData.TokenIndex;
    IntTokenType lastType = TokenType.NA;
    bool identifierFound = false;

    for formatData.IndexInBounds() {

        if index >= len(formatData.TokenList) {
            formatData.EndOfFileError(EmptyToken());
            return false;
        }
        Token token = formatData.TokenList[index];
        if token.Type == TokenType.LeftSquareBracket {

            if identifierFound == true {
                return false;
            }
            return true;
        }
        if token.Type == TokenType.Identifier {

            identifierFound = true;
            if lastType == TokenType.Identifier {
                return true;
            }
        } 
        if IsVarTypeEnum(token.Type) {
            return true;
        } 
        if IsAssignmentOperator(token.Type) {
            return false;
        }
        lastType = token.Type;
        index += 1;
    }
    return false;
}

fn bool HandleToken(*FormatData formatData, Token token, *[]Token returnTypeTokenList, *IntTokenType lastType) {
    formatData.SetErrorFunction("HandleToken");

    if IsVarTypeEnum(token.Type) {
        *returnTypeTokenList = append(*returnTypeTokenList, token);
        return false;
    }

    if token.Type == TokenType.Identifier {

        if *lastType == TokenType.Identifier || *lastType == TokenType.RightBrace {
            return true;
        }
        if IsVarTypeEnum(*lastType) {
            return true;
        }

        bool wasPartOfType =
            *lastType == TokenType.FullStop ||
            *lastType == TokenType.RightSquareBracket ||
            *lastType == TokenType.Multiply ||
            *lastType == TokenType.LeftParenthesis ||
            *lastType == TokenType.NA;

        if wasPartOfType {
            *returnTypeTokenList = append(*returnTypeTokenList, token);
            return false;
        }

        formatData.UnexpectedTypeError(token, "Found unexpected identifier in parameters");
        return true;
    }
    bool isSkippableToken =
        token.Type == TokenType.Tab ||
        token.Type == TokenType.NewLine ||
        token.Type == TokenType.RightParenthesis ||
        token.Type == TokenType.Comma;

    if isSkippableToken {
        return false;
    }
    *returnTypeTokenList = append(*returnTypeTokenList, token);
    return false;
}

fn IntLoopAction VarTypeInnerCode(*FormatData formatData, *[]Token returnTypeTokenList, *int whileCount, *IntTokenType lastType) {
    formatData.SetErrorFunction("VarTypeInnerCode");

    int MAX = 10000;

    if IsInfiniteWhile(whileCount, MAX) {
        formatData.Result = FormatResult.Internal_Error;
        formatData.ErrorDetail = "Infinite while loop in VarTypeInnerLoop, FormatUtils";
        return LoopAction.Error;
    }
    int indexBefore = formatData.TokenIndex;

    Token token = formatData.GetToken();
    if formatData.IsValidToken(token) == false {
        formatData.EndOfFileError(token);
        return LoopAction.Return;
    }

    bool shouldBreak = HandleToken(formatData, token, returnTypeTokenList, lastType);
    if shouldBreak == true {
        return LoopAction.Break;
    }

    formatData.IncrementIfSame(indexBefore);
    *lastType = token.Type;
    return LoopAction.Continue;
}

fn FillVarType(*FormatData formatData, *[]Token returnTypeTokenList) {

    formatData.SetErrorFunction("FillVarType");

    int whileCount = 0;

    IntTokenType lastType = TokenType.NA;

    //Get to ')' and then don't increment
    for formatData.IndexInBounds() {

        IntLoopAction iterationResult = VarTypeInnerCode(formatData, returnTypeTokenList, &whileCount, &lastType);
        if iterationResult == LoopAction.Break {
            break;
        }
        if iterationResult == LoopAction.Return {
            return;
        }
    }
}

fn LoopUntilRightParenthesis(*FormatData formatData, *[]Token returnTypeTokenList) {
    formatData.SetErrorFunction("LoopUntilRightParenthesis");

    int whileCount = 0;

    int openParenthesisCount = 1;

    for formatData.IndexInBounds() {
        int MAX = 10000;

        if IsInfiniteWhile(&whileCount, MAX) {
            formatData.Result = FormatResult.Internal_Error;
            formatData.ErrorDetail = "Infinite while loop in LoopUntilRightParenthesis, FormatUtils";
            return;
        }
        int indexBefore = formatData.TokenIndex;

        Token token = formatData.GetToken();
        if formatData.IsValidToken(token) == false {
            formatData.EndOfFileError(token);
            return;
        }

        *returnTypeTokenList = append(*returnTypeTokenList, token);

        formatData.IncrementIfSame(indexBefore);

        if token.Type == TokenType.LeftParenthesis {
            openParenthesisCount += 1;
        }

        if token.Type == TokenType.RightParenthesis {
            if openParenthesisCount != 1 {
                openParenthesisCount -= 1;
                continue;
            }
            break;
        }
    }
}

fn FindParameters(*FormatData formatData, *[]Variable parameters) {
    formatData.SetErrorFunction("FindParameters");

    int whileCount = 0;

    ParameterData parameter_data

    parameter_data.TempParameter = Variable{}
    parameter_data.TempParameter.SetToDefaults()
    parameter_data.LastTokenType = TokenType.LeftParenthesis
    parameter_data.ParameterPhase = ParameterPhase.TypeOrName
    parameter_data.Parameters = parameters

    //Get to ')' and then don't increment
    for formatData.IndexInBounds() {

        IntLoopAction iterationResult = ParameterInnerLoop(formatData, &parameter_data, &whileCount);
        if iterationResult == LoopAction.Break {
            break;
        }
        if iterationResult == LoopAction.Return {
            return;
        }
    }
}

fn IntLoopAction ParameterInnerLoop(*FormatData formatData, *ParameterData parameter_data, *int whileCount) {
    formatData.SetErrorFunction("ParameterInnerLoop");
    int MAX = 10000;

    if IsInfiniteWhile(whileCount, MAX) {
        formatData.Result = FormatResult.Internal_Error;
        formatData.ErrorDetail = "infinite while loop in ParameterInnerLoop, FunctionUtils";
        return LoopAction.Error;
    }
    int indexBefore = formatData.TokenIndex;

    Token token = formatData.GetToken();
    if formatData.IsValidToken(token) == false {
        formatData.EndOfFileError(token);
        return LoopAction.Return;
    }

    HandleParameterToken(formatData, token, parameter_data);

    if formatData.IsError() {
        return LoopAction.Return
    }

    if token.Type == TokenType.Comma {
        AddParameter(parameter_data);
        parameter_data.ParameterPhase = ParameterPhase.TypeOrName
    }
    if token.Type == TokenType.RightParenthesis {
        AddParameter(parameter_data);
        return LoopAction.Break;
    }

    formatData.IncrementIfSame(indexBefore);
    parameter_data.LastTokenType = token.Type;
    return LoopAction.Continue;
}

fn HandleParameterToken(*FormatData formatData, Token token, *ParameterData parameter_data) {

    if token.Type == TokenType.Identifier {

        if parameter_data.ParameterPhase == ParameterPhase.End {
			formatData.UnexpectedTypeError(token, "expected comma or ) in parameters")
            return
        }

        if parameter_data.LastTokenType == TokenType.Identifier || parameter_data.LastTokenType == TokenType.RightBrace {
            parameter_data.TempParameter.NameToken.append(token);
            parameter_data.ParameterPhase = ParameterPhase.End
            return;
        }
        if IsVarTypeEnum(parameter_data.LastTokenType) {
            parameter_data.TempParameter.NameToken.append(token);
            return;
        }

        bool wasPartOfType =
            parameter_data.LastTokenType == TokenType.FullStop ||
            parameter_data.LastTokenType == TokenType.RightSquareBracket ||
            parameter_data.LastTokenType == TokenType.Multiply ||
            parameter_data.LastTokenType == TokenType.Comma ||
            parameter_data.LastTokenType == TokenType.LeftParenthesis;

        if wasPartOfType {
            parameter_data.TempParameter.TypeList.append(token);
            return;
        }

        formatData.UnexpectedTypeError(token, "Found unexpected identifier in parameters");
        return;
    }
    bool isSkippableToken =
        token.Type == TokenType.Tab ||
        token.Type == TokenType.NewLine ||
        token.Type == TokenType.RightParenthesis ||
        token.Type == TokenType.Comma;

    if isSkippableToken {
        return;
    }
    parameter_data.TempParameter.TypeList.append(token);
}

fn AddParameter(*ParameterData parameter_data) {

    if parameter_data.TempParameter.NameToken == nil {
        return;
    }
    int parameter_count = len(parameter_data.TempParameter.TypeList)
    if parameter_count == 0 {
        return;
    }
    Variable parameterCopy;
    parameterCopy.TypeList = make([]Token, 0)
    for i := 0; i < parameter_count; i++ {
        parameterCopy.TypeList.append(parameter_data.TempParameter.TypeList[i]);
    }
    parameterCopy.NameToken = CopyTokenList(parameter_data.TempParameter.NameToken);

    *parameter_data.Parameters = append(*parameter_data.Parameters, parameterCopy);
    parameter_data.TempParameter.SetToDefaults();
}

fn string ConcatStrings([]string slice) {
	strings.Builder result
	for _, s := range slice {
		result.WriteString(s)
	}
	return result.String()
}