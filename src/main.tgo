package main

import (
    "fmt"
    . "TypeGo/core"
    . "TypeGo/parse"
    . "TypeGo/formatting"
	"TypeGo/language_server"
    "TypeGo/converting"
	"os"
	//"golang.org/x/sys/windows"
    "strings"
    "path/filepath"
)

//func enableVirtualTerminalProcessing() {
	//windows.Handle stdout = windows.Handle(os.Stdout.Fd());
	//uint32 mode;
	//windows.GetConsoleMode(stdout, &mode);
	//mode = mode | windows.ENABLE_VIRTUAL_TERMINAL_PROCESSING;
	//windows.SetConsoleMode(stdout, mode);
//}

fn string convertToGo(string code, *bool success, string file_name) {

	fmt.Printf("\tConverting %s\t", file_name)

    IntParseResult parse_result = ParseResult.Ok
    []Token token_list = ParseToTokens(&parse_result, code)
    if parse_result.IsError() {
		parse_result.Println()
        *success = false
        return ""
    }
    //PrintTokenList(token_list)

    IntFormatResult format_result = FormatResult.Ok
    CodeFormat code_format = FormatCode(token_list, &format_result, code)
    if format_result.IsError() {
        format_result.Println()
        *success = false
        return ""
    }
	//code_format.Print()

    IntConvertResult convert_result = ConvertResult.Ok
    string generated_code = converting.ConvertToGo(&code_format, &convert_result, code)
    if convert_result.IsError() {
		convert_result.Println()
        *success = false
        return ""
    }

	*success = true
    return generated_code
}

fn testingInput() {
    string code = `


`

    fmt.Println("Imported code:\n", code);

    bool success = true
    string go_code = convertToGo(code, &success, "None")
    if success == false {
        return
    }

    fmt.Println("Done")
    fmt.Println("Converted Go code: \n", go_code)

    error err = os.WriteFile("output.txt", []byte(go_code), 0644)
    errcheck {
        fmt.Println("Error writing file:", err)
        return
    }
    fmt.Println("Output written to output.txt")
}

fn bool ConvertDirectory(string currentDirectory) {

	[]os.DirEntry entries
	error err
	entries, err = os.ReadDir(currentDirectory)
	errcheck {
		fmt.Println("Error: ", err)
		return false
	}

	for _, entry := range entries {

		string fullPath = filepath.Join(currentDirectory, entry.Name())
		
		if entry.IsDir() {
			 // Recursively walk subdirectories
			bool success = ConvertDirectory(fullPath)
			if success == false {
				return false
			}

		} else  {
			 // Process file
			_ = ConvertAndWriteFile(fullPath, entry.Name())
		}

	}
	return true
}

fn bool ConvertAndWriteFile(string tgoFilePath, string file_name) {

    bool has_suffix = strings.HasSuffix(tgoFilePath, ".tgo")

    if has_suffix == false {
        return false
    }

	[]byte tgoCodeBytes
	error readError
	tgoCodeBytes, readError = os.ReadFile(tgoFilePath)
	if readError != nil {
		return false
	}

	string tgoCode = string(tgoCodeBytes)

	string goCode

	bool success
	if file_name == "" {
		goCode = convertToGo(tgoCode, &success, "unknown")
	} else {
		goCode = convertToGo(tgoCode, &success, file_name)
	}
	if success == false {
		return false
	}

	if goCode == "" {
		return false
	}

	string goPath = strings.TrimSuffix(tgoFilePath, filepath.Ext(tgoFilePath)) + ".go"

	error writeError = os.WriteFile(goPath, []byte(goCode), 0644)
	if writeError != nil {
		return false
	}

	fmt.Printf("%sDone%s\n", CYAN_TEXT, RESET_TEXT)
	return true
}

fn bool ConvertFile(string filePath) {

    bool has_suffix = strings.HasSuffix(filePath, ".tgo")

    if has_suffix == false {
        return false
    }

	os.FileInfo fileInfo
	error err
	fileInfo, err = os.Stat(filePath)
	if err != nil {
		if os.IsNotExist(err) {
			fmt.Println("Error: File not found:", filePath)
			return false
		}

		// Other filesystem error
		fmt.Println("Error accessing file:", filePath)
		return false
	}

	if fileInfo.IsDir() {
		fmt.Println("Error: Path is a directory:", filePath)
		return false
	}

	return ConvertAndWriteFile(filePath, filePath)
}


const HELP = "help"
const VERSION = "version"
const CONVERT_DIRECTORY = "convertdir"
const CONVERT_FILE      = "convertfile"
const CONVERT_FILE_ABS = "convertfileabs"
const LSP 		= "start_lsp"

fn ConsoleInput([]string args) {

	if len(args) == 0 {
		ShowHelp()
		return
	}

	string command = strings.ToLower(args[0])

	string current_working_directory
	error err
    string file_path
	bool ok = true

	switch command {

	case HELP:
		ShowHelp()

	case VERSION:
		fmt.Println("TypeGo version 0.4")

	case CONVERT_FILE:
		if len(args) < 2 {
			fmt.Println("Error: You must specify a filename (e.g. typego convertfile myfile.tgo)")
			os.Exit(1)
		} 

		current_working_directory, err = os.Getwd()
		errcheck {
			fmt.Println("Error getting current directory:", err)
			os.Exit(1)
		}

		file_path = filepath.Join(current_working_directory, args[1])
		ok = ConvertFile(file_path)
		if ok == false {
			os.Exit(1)
		}

	case CONVERT_FILE_ABS:
		ok = ConvertFile(args[1])
		if ok == false {
			os.Exit(1)
		}

	case CONVERT_DIRECTORY:

		current_working_directory, err = os.Getwd()
		errcheck {
			fmt.Println("Error getting current directory:", err)
			return
		}
		ok = ConvertDirectory(current_working_directory)
		if ok == false {
			fmt.Println("Error, exit 1")
			os.Exit(1)
		}
		fmt.Println("Done")

	case LSP:
		language_server.Run()

	default:
		fmt.Printf("Unknown command: %s\n", command)
		ShowHelp()
	}
}

fn ShowHelp() {
	fmt.Println("TypeGo");
	fmt.Println("Usage:");
	fmt.Println("  tgo help                 Show this help message");
	fmt.Println("  tgo version              Show the version of TypeGo");
	fmt.Println("  tgo convertfile file.tgo   Convert a single .tgo file in the current directory");
	fmt.Println("  tgo convertdir           Convert all .tgo files in the current directory (recursively)");
	fmt.Println("  tgo convertfileabs file.tgo - Convert a single .tgo file with an absolute directory")
	fmt.Println("  tgo lsp - starts the language server")
}

fn main() {

    //enableVirtualTerminalProcessing()
    //testingInput()
    []string args = os.Args[1:]
    ConsoleInput(args)
}