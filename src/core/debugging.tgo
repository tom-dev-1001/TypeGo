package core

import (
    "fmt"
	"strings"
)

fn PrintTokenList([]Token token_list) {
	fmt.Println(CYAN_TEXT, "\nPrinting Token List:", RESET_TEXT);
	int list_count = len(token_list);
	if list_count == 0 {
		fmt.Println("Token list is zero");
		return;
	}
	for i := 0; i < list_count; i++ {
		fmt.Printf("\t%sToken:%s %s'%s'%s, %stype:%s %s'%s'%s, %sline number:%s %s%d%s, %schar count:%s %s%d%s\n", 
			GREY_TEXT,
			RESET_TEXT,

			ORANGE_TEXT,
			token_list[i].Text, 
			RESET_TEXT,

			GREY_TEXT,
			RESET_TEXT,

			CREAM_TEXT,
			token_list[i].Type.ToString(), 
			RESET_TEXT,

			GREY_TEXT,
			RESET_TEXT,

			LIGHT_GREEN_TEXT,
			token_list[i].LineNumber, 
			RESET_TEXT,

			GREY_TEXT,
			RESET_TEXT,

			LIGHT_GREEN_TEXT,
			token_list[i].CharNumber,
			RESET_TEXT,
		);
	}
	fmt.Println();
}

fn PrintFormatError(*FormatData formatData, string code) {

	Token error_token = formatData.ErrorToken;
	if error_token.Type == TokenType.NA {

		if formatData.Result == FormatResult.EndOfFile {
			error_token = FindLastToken(formatData);
		}

	}
	int line_number = GetLineNumber(error_token);
	int char_number = GetCharNumber(error_token);

	[]string codeLines = strings.Split(code, "\n")

	string code_line = GetCodeLine(line_number, codeLines);

	fmt.Printf("\t%sError on line %d, %d: %s%s\n", CREAM_TEXT, line_number, char_number, formatData.ErrorDetail, RESET_TEXT);

	PrintCodeLines(line_number, codeLines, code_line);
	pointToErrorPosition(char_number)
	PrintErrorToken(error_token);

	fmt.Printf("\tError Function: %s%s\n", CREAM_TEXT, formatData.ErrorFunction);
	fmt.Printf("\tError Process: %s%s\n", formatData.ErrorProcess, RESET_TEXT);
	//formatData.PrintProcessLog()
}

fn pointToErrorPosition(int char_number) {
	[]byte temp_curly_lines = make(0)
    for i := 0; i < char_number; i++ {
        temp_curly_lines.append('~')
    }
    string curly_lines = string(temp_curly_lines)
    fmt.Printf("\t%s%s^%s\n", GREEN_TEXT, curly_lines, RESET_TEXT)
}

fn PrintConvertError(*ConvertData convertData, string code) {

	Token error_token = convertData.ErrorToken;
	int line_number = GetLineNumber(error_token);
	int char_number = GetCharNumber(error_token);

	[]string codeLines = strings.Split(code, "\n")

	string code_line = GetCodeLine(line_number, codeLines);

	fmt.Printf("\t%sError on line %d, %d: %s%s\n", CREAM_TEXT, line_number, char_number, convertData.ErrorDetail, RESET_TEXT);

	PrintCodeLines(line_number, codeLines, code_line);
	pointToErrorPosition(char_number)
	PrintErrorToken(error_token);

	fmt.Printf("\tError Function: %s%s\n", CREAM_TEXT, convertData.ErrorFunction);
	fmt.Printf("\tError Process: %s%s\n", convertData.ErrorProcess, RESET_TEXT);
	//convertData.PrintProcessLog()
}

fn string GetCodeLine(int line_number, []string codeLines) {
	if line_number >= len(codeLines) || line_number < 0 {
		return "Invalid";
	} else {
		return codeLines[line_number];
	}
}

fn PrintCodeLines(int line_number, []string codeLines, string code_line) {
	if line_number - 1 >= 0 && line_number < len(codeLines) {
		fmt.Printf("\t%s\n", codeLines[line_number - 1]);
	}
	fmt.Printf("\t%s\n", code_line);
}

fn PrintErrorToken(Token error_token) {
	fmt.Print("\tToken: "); 
	if error_token.Type != TokenType.NA {
		fmt.Printf("%s'%s'%s\n", ORANGE_TEXT, error_token.Text, RESET_TEXT);
	} else {
		fmt.Println("Error token not set");
	}
}

fn int GetLineNumber(Token error_token) {
	if error_token.Type == TokenType.NA {
		return -1;
	}
	return error_token.LineNumber;
}
fn int GetCharNumber(Token error_token) {
	if error_token.Type == TokenType.NA {
		return -1;
	}
	return error_token.CharNumber;
}

fn Token FindLastToken(*FormatData formatData) {

	int count = len(formatData.TokenList);
	if count == 0 {
		return EmptyToken();
	}

	return formatData.GetTokenByIndex(count - 1);
}
         