package converting

import . "TypeGo/core"

fn AddParameter([]Variable parameters, *Variable tempParameter) {
    if tempParameter.NameToken == nil {
        return;
    }
    if len(tempParameter.TypeList) == 0 {
        return;
    }
    Variable parameterCopy = {};
    parameterCopy.TypeList = make([]Token, 0)
    for i := 0; i < len(tempParameter.TypeList); i++ {
        parameterCopy.TypeList.append(tempParameter.TypeList[i]);
    }
    parameterCopy.NameToken = CopyTokenList(tempParameter.NameToken);

    parameters.append(parameterCopy);
    tempParameter.SetToDefaults();
}

fn HandleTokenParameter(*FormatData formatData, Token token, *Variable tempParameter, *IntTokenType lastType) {

    if token.Type == TokenType.Identifier {

        if *lastType == TokenType.Identifier || *lastType == TokenType.RightBrace {
            tempParameter.NameToken.append(token);
            return;
        }
        if IsVarTypeEnum(*lastType) {
            tempParameter.NameToken.append(token);
            return;
        }

        bool wasPartOfType =
            *lastType == TokenType.FullStop ||
            *lastType == TokenType.RightSquareBracket ||
            *lastType == TokenType.Multiply ||
            *lastType == TokenType.Comma ||
            *lastType == TokenType.LeftParenthesis;

        if wasPartOfType {
            tempParameter.TypeList.append(token);
            return;
        }

        formatData.UnexpectedTypeError(token, "Found unexpected identifier in parameters");
        return;
    }
    bool isSkippableToken =
        token.Type == TokenType.Tab ||
        token.Type == TokenType.NewLine ||
        token.Type == TokenType.RightParenthesis ||
        token.Type == TokenType.Comma;

    if isSkippableToken {
        return;
    }
    tempParameter.TypeList.append(token);
}

fn IntLoopAction ParameterInnerLoop(*FormatData formatData, *[]Variable parameters, *Variable tempParameter, *int whileCount, *IntTokenType lastType) {

    formatData.SetErrorFunction("ParameterInnerLoop");
    int MAX = 10000;

    if *whileCount >= MAX {
        formatData.Result = FormatResult.Internal_Error;
        formatData.ErrorDetail = "infinite while loop in ParameterInnerLoop, FunctionUtils";
        return LoopAction.Error;
    }
    *whileCount += 1
    int indexBefore = formatData.TokenIndex;

    Token token = formatData.GetToken();
    if token.Text == "" {
        formatData.EndOfFileError(token);
        return LoopAction.Return;
    }

    HandleTokenParameter(formatData, token, tempParameter, lastType);

    if token.Type == TokenType.Comma {
        AddParameter(*parameters, tempParameter);
    }
    if token.Type == TokenType.RightParenthesis {
        AddParameter(*parameters, tempParameter);
        return LoopAction.Break;
    }

    formatData.IncrementIfSame(indexBefore);
    *lastType = token.Type;
    return LoopAction.Continue;
}

fn FindParameters(*FormatData formatData, []Variable parameters) {

    formatData.SetErrorFunction("FindParameters")

    int whileCount = 0;

    Variable tempParameter = {};
    tempParameter.SetToDefaults();
    IntTokenType lastType = TokenType.LeftParenthesis;

    //Get to ')' and then don't increment
    for formatData.TokenIndex < len(formatData.TokenList) {

        IntLoopAction iterationResult = ParameterInnerLoop(formatData, &parameters, &tempParameter, &whileCount, &lastType);
        if iterationResult == LoopAction.Break {
            break;
        }
        if iterationResult == LoopAction.Return {
            return;
        }
    }
}