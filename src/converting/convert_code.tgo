package converting

import (
    . "TypeGo/core"
    "fmt"
)

func bool InfiniteWhileCheck(*int whileCount, int MAX) {
	*whileCount += 1
	if *whileCount >= MAX {
		return true
	}
	return false
}

fn bool ShouldReturn(*ConvertData convertData, *int whileCount, int WHILE_CAP) {

    if InfiniteWhileCheck(whileCount, WHILE_CAP) {
        convertData.ConvertResult = ConvertResult.Internal_Error;
        convertData.ErrorDetail = "InfiniteWhileLoop in Should Return";
        return true;
    }
    if convertData.IsError() {
        return true;
    }
    return false;
}

fn PrintCodeFormat(*ConvertData convertData) {
    convertData.SetErrorFunction("LoopTokens")

    CodeBlock globalBlock = convertData.CodeFormat.GlobalBlock;

    int nest_count = 0
    bool is_global = true
    ProcessBlock(convertData, &globalBlock, nest_count, is_global);
    if convertData.IsError() {
		return
	}

    []Function functions = convertData.CodeFormat.Functions;

    for functionIndex := 0; functionIndex < len(functions); functionIndex++ {

        ProcessFunction(convertData, &functions[functionIndex]);

        if convertData.IsError() {
            return;
        }
    }
}

fn string ConvertToGo(*CodeFormat codeFormat, *IntConvertResult convertResult, string code) {
    //fmt.Printf("\t%sConverting:%s\t\t\t", GREY_TEXT, RESET_TEXT);
    ConvertData convertData = {
        CodeFormat: *codeFormat,
        ErrorDetail: "",
        ConvertResult: ConvertResult.Ok,
        GeneratedCode: make([]byte, 0),
    };

    PrintCodeFormat(&convertData);
    if convertData.IsError() {
        fmt.Printf("Error %s%s%s\n", RED_TEXT, convertData.ConvertResult.ToString(), RESET_TEXT);
        PrintConvertError(&convertData, code);
        return "";
    }

    //fmt.Printf("%sDone%s\n", CYAN_TEXT, RESET_TEXT);

    return string(convertData.GeneratedCode);
}