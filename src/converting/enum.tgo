package converting

import (
	. "TypeGo/core"
	"strconv"
)

fn ProcessEnum(*ConvertData convertData, *BlockData blockData, int nestCount) {
    
    if blockData.Tokens == nil {
        convertData.ConvertResult = ConvertResult.Internal_Error;
        convertData.ErrorDetail = "Tokens was null in ProcessEnum, PrintEnum";
        return;
    }
    if len(blockData.Tokens) != 1 {
        convertData.ConvertResult = ConvertResult.Internal_Error;
        convertData.ErrorDetail = "Tokens count wasn't 1 in ProcessEnum, PrintEnum";
        return;
    }
    string enumNameText = blockData.Tokens[0].Text;

    convertData.AppendString("type " + enumNameText + " int\n\n");

    *CodeBlock enumVariableBlock = blockData.Block;
    if enumVariableBlock == nil {
        convertData.AppendChar('\n');
        EndEnum(convertData);
        return;
    }

    if enumVariableBlock.BlockDataList == nil {
        convertData.ConvertResult = ConvertResult.Internal_Error;
        convertData.ErrorDetail = "BlockDataList was null in ProcessEnum, PrintEnum";
        return;
    }

    []BlockData blockDataList = enumVariableBlock.BlockDataList;

    if len(blockDataList) == 0 {
        convertData.AppendChar('\n');
        EndEnum(convertData);
        return;
    }

    convertData.AppendString("const (\n\t");

    int enumCount = 0;

    convertData.IncrementNestCount()
    for blockIndex := 0; blockIndex < len(blockDataList); blockIndex++ {

        BlockData varBlock = blockDataList[blockIndex];

        int tokenCount = len(varBlock.Tokens);

        if tokenCount == 0 {
            continue;
        }

        if tokenCount == 1 || tokenCount == 2 {

            Token onlyToken = varBlock.Tokens[0];

            convertData.AppendString(enumNameText);
            convertData.AppendString(onlyToken.Text);
            convertData.AppendString(" = " + strconv.Itoa(enumCount));
            enumCount += 1;
            convertData.NewLineWithTabs();
            continue;
        }

        if tokenCount == 3 {

            Token firstToken = varBlock.Tokens[0];
            Token secondToken = varBlock.Tokens[1];

            if secondToken.Text != "=" {
                convertData.MissingTypeError(secondToken, "missing expect '=' in enumstruct");
                return;
            }

            int value, error err = strconv.Atoi(secondToken.Text)
            errcheck {
                convertData.MissingTypeError(secondToken, "missing expected integer in enumstruct");
                return;
            }

            convertData.AppendString(enumNameText);
            convertData.AppendString(firstToken.Text);
			convertData.AppendString(" = " + strconv.Itoa(value))
            enumCount = value + 1;
            convertData.NewLineWithTabs();
        }
    }
    convertData.DecrementNestCount()

    convertData.AppendChar('\n');
    EndEnum(convertData);

    convertData.AppendString("func (self " + enumNameText +  ") ToString() string {\n\t");
    convertData.AppendString("switch self {\n\t");

    for blockIndex := 0; blockIndex < len(blockDataList); blockIndex++ {

        BlockData varBlock = blockDataList[blockIndex];

        for i := 0; i < len(varBlock.Tokens); i++ {

            Token token = varBlock.Tokens[i];

            convertData.AppendString("case " + enumNameText + token.Text + ":\n\t\t");
            convertData.AppendString("return \"" + token.Text + "\"\n\t");
            break;
        }
    }
    convertData.AppendString("default:\n\t\t");
    convertData.AppendString("return \"Unknown\"\n\t");
    convertData.AppendChar('}');
    convertData.AppendChar('\n');
    convertData.AppendChar('}');
    convertData.AppendChar('\n');
    convertData.AppendChar('\n');
    PrintEnumMethods(convertData, enumVariableBlock, nestCount, enumNameText)
}

fn ProcessEnumstruct(*ConvertData convertData, *BlockData blockData, int nestCount) {
    if blockData.Tokens == nil {
        convertData.ConvertResult = ConvertResult.Internal_Error;
        convertData.ErrorDetail = "Tokens null in ProcessEnumstruct";
        return;
    }
    if len(blockData.Tokens) != 1 {
        convertData.ConvertResult = ConvertResult.Internal_Error;
        convertData.ErrorDetail = "Tokens count != 1 in ProcessEnumstruct";
        return;
    }
    string enumNameText = blockData.Tokens[0].Text;

    string alias_name = "Int" + enumNameText

    convertData.AppendString("type " + alias_name + " int\n")

    convertData.AppendString("var " + enumNameText + " = struct {");


    *CodeBlock enumVariableBlock = blockData.Block;
    if enumVariableBlock == nil {
        convertData.AppendChar('\n');
        EndEnumStruct(convertData);
        return;
    }

    if enumVariableBlock.BlockDataList == nil {
        convertData.ConvertResult = ConvertResult.Internal_Error;
        convertData.ErrorDetail = "BlockDataList is null in ProcessEnumstruct";
        return;
    }

    []BlockData blockDataList = enumVariableBlock.BlockDataList;

    if len(blockDataList) == 0 {
        convertData.AppendChar('\n');
        EndEnumStruct(convertData);
        return;
    }

    convertData.AppendString("\n\t");

    convertData.IncrementNestCount()
    for blockIndex := 0; blockIndex < len(blockDataList); blockIndex++ {

        BlockData varBlock = blockDataList[blockIndex];

        for i := 0; i < len(varBlock.Tokens); i++ {
            Token token = varBlock.Tokens[i];

            convertData.AppendString(token.Text);
            convertData.AppendString(" " + alias_name);
            convertData.NewLineWithTabs();
            break;
        }
    }

    convertData.AppendChar('\r');
    convertData.AppendChar('}');
    convertData.AppendChar('{');
    convertData.NewLineWithTabs();

    int enumCount = 0;

    for blockIndex := 0; blockIndex < len(blockDataList); blockIndex++ {

        BlockData varBlock = blockDataList[blockIndex];

        int tokenCount = len(varBlock.Tokens);

        if tokenCount == 0 {
            continue;
        }

        if tokenCount == 1 || tokenCount == 2 {

            Token onlyToken = varBlock.Tokens[0];

            convertData.AppendString(onlyToken.Text);
			convertData.AppendString(": " + strconv.Itoa(enumCount) + ",")
            enumCount += 1;
            convertData.NewLineWithTabs();
            continue;
        }

        if tokenCount == 3 {

            Token firstToken = varBlock.Tokens[0];
            Token secondToken = varBlock.Tokens[1];
            Token thirdToken = varBlock.Tokens[2]

            if secondToken.Text != "=" {
                convertData.MissingTypeError(secondToken, "missing expect '=' in enumstruct");
                return;
            }


            int value, error err = strconv.Atoi(thirdToken.Text)
            errcheck {
                convertData.MissingTypeError(thirdToken, "missing expected integer in enumstruct");
                return;
            }

            convertData.AppendString(firstToken.Text);
			convertData.AppendString(": " + strconv.Itoa(value) + ",")
            enumCount = value + 1;
            convertData.NewLineWithTabs();
        }
    }
    convertData.DecrementNestCount()

    convertData.AppendChar('\r');
    EndEnumStruct(convertData);

    convertData.AppendString("func (self " + alias_name  + ") ToString() string {\n\t");
    convertData.AppendString("switch self {\n\t");

    for blockIndex := 0; blockIndex < len(blockDataList); blockIndex++ {

        BlockData varBlock = blockDataList[blockIndex];

        for i := 0; i < len(varBlock.Tokens); i++ {
            Token token = varBlock.Tokens[i];

            convertData.AppendString("case " + enumNameText + "." + token.Text + ":\n\t\t");
            convertData.AppendString("return \"" + token.Text + "\"\n\t");
            break;
        }
    }
    convertData.AppendString("default:\n\t\t");
    convertData.AppendString("return \"Unknown\"\n");
    convertData.AppendChar('\t');
    convertData.AppendChar('}');
    convertData.AppendChar('\n');
    convertData.AppendChar('\r');
    convertData.AppendChar('}');
    convertData.AppendChar('\n');
    convertData.AppendChar('\n');
    PrintEnumMethods(convertData, enumVariableBlock, nestCount, alias_name)
}

fn ProcessEnumstructWithAlias(*ConvertData convertData, *BlockData blockData, int nestCount) {

    if blockData.Tokens == nil {
        convertData.ConvertResult = ConvertResult.Internal_Error;
        convertData.ErrorDetail = "Tokens null in ProcessEnumstruct";
        return;
    }
    if len(blockData.Tokens) != 1 {
        convertData.ConvertResult = ConvertResult.Internal_Error;
        convertData.ErrorDetail = "Tokens count != 1 in ProcessEnumstruct";
        return;
    }
    string enumNameText = blockData.Tokens[0].Text;

    if blockData.VarName == "" {
        convertData.ConvertResult = ConvertResult.Missing_Expected_Type;
        convertData.ErrorDetail = "Alias name is null in enumstruct";
        convertData.ErrorToken = blockData.StartingToken;
        return;
    }

    string var_type = blockData.VarName;

    convertData.AppendString("type " + var_type + " int\n");

    convertData.AppendString("var " + enumNameText + " = struct {");


    *CodeBlock enumVariableBlock = blockData.Block;
    if enumVariableBlock == nil {
        convertData.AppendChar('\n');
        EndEnum(convertData);
        return;
    }

    if enumVariableBlock.BlockDataList == nil {
        convertData.ConvertResult = ConvertResult.Internal_Error;
        convertData.ErrorDetail = "BlockDataList is null in ProcessEnumstruct";
        return;
    }

    []BlockData blockDataList = enumVariableBlock.BlockDataList;

    if len(blockDataList) == 0 {
        convertData.AppendChar('\n');
        EndEnum(convertData);
        return;
    }

    convertData.AppendString("\n\t");

    for blockIndex := 0; blockIndex < len(blockDataList); blockIndex++ {

        BlockData varBlock = blockDataList[blockIndex];

        for i := 0; i < len(varBlock.Tokens); i++ {
            Token token = varBlock.Tokens[i];

            convertData.AppendString(token.Text);
            convertData.AppendString(" " + var_type);
            convertData.NewLineWithTabs();
            break;
        }
    }

    convertData.AppendChar('\r');
    convertData.AppendChar('}');
    convertData.AppendChar('{');
    convertData.NewLineWithTabs();

    int enumCount = 0;

    for blockIndex := 0; blockIndex < len(blockDataList); blockIndex++ {

        BlockData varBlock = blockDataList[blockIndex];

        int tokenCount = len(varBlock.Tokens);

        if tokenCount == 0 {
            continue;
        }

        if tokenCount == 1 || tokenCount == 2 {

            Token onlyToken = varBlock.Tokens[0];

            convertData.AppendString(onlyToken.Text);
			convertData.AppendString(": " + strconv.Itoa(enumCount) + ",")
            enumCount += 1;
            convertData.NewLineWithTabs();
            continue;
        }

        if tokenCount == 3 {

            Token firstToken = varBlock.Tokens[0];
            Token secondToken = varBlock.Tokens[1];
            Token thirdToken = varBlock.Tokens[2];

            if secondToken.Text != "=" {
                convertData.MissingTypeError(secondToken, "missing expect '=' in enumstruct");
                return;
            }

            int value, error err = strconv.Atoi(thirdToken.Text)
            errcheck {
                convertData.MissingTypeError(thirdToken, "missing expected integer in enumstruct");
                return;
            }

            convertData.AppendString(firstToken.Text);
			convertData.AppendString(": " + strconv.Itoa(value) + ",")
            enumCount = value + 1;
            convertData.NewLineWithTabs();
        }
    }

    convertData.AppendChar('\r');
    EndEnumStruct(convertData);

    convertData.AppendString("func (self " + var_type  + ") ToString() string {\n\t");
    convertData.AppendString("switch self {\n\t");

    for blockIndex := 0; blockIndex < len(blockDataList); blockIndex++ {

        BlockData varBlock = blockDataList[blockIndex];

        for i := 0; i < len(varBlock.Tokens); i++ {
            Token token = varBlock.Tokens[i];

            convertData.AppendString("case " + enumNameText + "." + token.Text + ":\n\t\t");
            convertData.AppendString("return \"" + token.Text + "\"\n\t");
            break;
        }
    }
    convertData.AppendString("default:\n\t\t");
    convertData.AppendString("return \"Unknown\"\n");
    convertData.AppendChar('}');
    convertData.AppendChar('\n');
    convertData.AppendChar('\r');
    convertData.AppendChar('}');
    convertData.AppendChar('\n');
    convertData.AppendChar('\n');
    PrintEnumMethods(convertData, enumVariableBlock, nestCount, var_type)
}

fn PrintEnumMethods(*ConvertData convertData, *CodeBlock enumBlock, int nestCount, string enumName) {

    []Function functions = enumBlock.MethodList;
    if functions == nil {
        return;
    }
    if len(functions) == 0 {
        return;
    }

    convertData.MethodType = MethodType.Enum;
    convertData.StructName = enumName;

    for i := 0; i < len(functions); i++ {
        ProcessFunction(convertData, &functions[i]);
    }
    convertData.MethodType = MethodType.None;
    convertData.MethodVarNames = nil
}

fn EndEnum(*ConvertData convertData) {
    convertData.AppendChar(')');
    convertData.AppendChar('\n');
    convertData.AppendChar('\n');
}

fn EndEnumStruct(*ConvertData convertData) {
    convertData.AppendChar('}');
    convertData.AppendChar('\n');
    convertData.AppendChar('\n');
}